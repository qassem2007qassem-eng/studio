/**
 * @fileoverview Firestore Security Rules for the Syrian Student Hub application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data (profiles, notifications, stories, summaries)
 * while allowing public read access to posts. Write access to posts is restricted to the owner of the post, except for likes.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profiles, accessible only by the user themselves.
 * - /posts/{postId}: Stores posts, publicly readable, but writable only by the author. Liking is allowed by any authenticated user.
 * - /posts/{postId}/comments/{commentId}: Stores comments, writable only by the author and requires the authorId in the request to match the user id.
 * - /follows/{followId}: Stores follow relationships. Anyone can create a follow relationship.
 * - /users/{userId}/notifications/{notificationId}: Stores notifications, accessible only by the user.
 * - /reports/{reportId}: Stores reports of inappropriate content.
 * - /users/{userId}/stories/{storyId}: Stores stories, accessible only by the user.
 * - /users/{userId}/summaries/{summaryId}: Stores summaries, accessible only by the user.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Posts are publicly readable, but only the author can modify or delete them, except for likes.
 * - Any authenticated user can like or unlike a post.
 * - User listing is not allowed.
 *
 * Denormalization for Authorization:
 * - The `Post` entity includes an `authorId` field, enabling direct ownership checks without additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the request is made by the owner of the resource.
     * @param {string} userId The user ID to compare with the request's auth UID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the request is made by the existing owner of the resource.
     * @param {string} userId The user ID to compare with the resource's data.
     * @return {boolean} True if the user is the existing owner, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces user-ownership for profile data.
     * @path /users/{userId}
     * @allow (create) Signed-in user with matching userId in the path and data.
     * @allow (get, update, delete) Signed-in user whose UID matches the userId in the path.
     * @deny (create) User not signed in.
     * @deny (get, update, delete) User not signed in, or UID does not match userId in the path.
     * @principle Enforces document ownership for writes, restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to posts, but restricts write access to the author.
     * @path /posts/{postId}
     * @allow (get, list) Anyone can read all posts.
     * @allow (create) Signed-in user creating a post with a matching authorId.
     * @allow (update) Signed-in user who is the author of the post OR any signed-in user liking/unliking the post.
     * @allow (delete) Signed-in user who is the author of the post.
     * @deny (create) User not signed in, or authorId does not match.
     * @deny (update, delete) User not signed in, or not the author of the post for most fields.
     * @principle Allows public read, enforces owner-only writes based on the authorId field, but allows likes from anyone.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && (
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likeIds'])) ||
        (resource.data.authorId == request.auth.uid)
      );
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Enforces that comments belong to a post, and write access is restricted to the author.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get, list) Anyone can read comments for a post.
     * @allow (create) Signed-in user creating a comment with a matching authorId and postId.
     * @allow (update, delete) Signed-in user who is the author of the comment.
     * @deny (create) User not signed in, or authorId/postId does not match.
     * @deny (update, delete) User not signed in, or not the author of the comment.
     * @principle Enforces owner-only writes based on the authorId field.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid && request.resource.data.postId == postId;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;
    }

    /**
     * @description Allows anyone to create follow relationships.
     * @path /follows/{followId}
     * @allow (create) Signed-in user creating a follow relationship.
     * @deny (get, list, update, delete) Not allowed.
     */
    match /follows/{followId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Enforces user-ownership for notifications.
     * @path /users/{userId}/notifications/{notificationId}
     * @allow (get, list, create, update, delete) Signed-in user whose UID matches the userId in the path.
     * @deny (get, list, create, update, delete) User not signed in, or UID does not match userId in the path.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/notifications/{notificationId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to create reports.
     * @path /reports/{reportId}
     * @allow (create) Signed-in user creating a report.
     * @deny (get, list, update, delete) Not allowed.
     */
    match /reports/{reportId} {
      allow get: if false;
      allow list: if false;
      allow create: if isSignedIn();
      update: if false;
      delete: if false;
    }

    /**
     * @description Enforces user-ownership for stories.
     * @path /users/{userId}/stories/{storyId}
     * @allow (get, list, create, update, delete) Signed-in user whose UID matches the userId in the path.
     * @deny (get, list, create, update, delete) User not signed in, or UID does not match userId in the path.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/stories/{storyId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces user-ownership for summaries.
     * @path /users/{userId}/summaries/{summaryId}
     * @allow (get, list, create, update, delete) Signed-in user whose UID matches the userId in the path.
     * @deny (get, list, create, update, delete) User not signed in, or UID does not match userId in the path.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/summaries/{summaryId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }
  }
}
// Updated to trigger Firestore database creation.

    